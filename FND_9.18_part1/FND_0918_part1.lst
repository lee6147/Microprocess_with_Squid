Interrupt Vectors
00000 940C 004D JMP	__start|__text_start
Program Code (text area)
_exit:
    0006F CFFF      RJMP	_exit
FILE: C:\Users\user\OneDrive\Desktop\마이크로프로세서\FND_0918_part1\main.c
(0001) // ▼▼▼▼▼▼▼▼▼▼ 필요한 부품 및 설명서 불러오기 ▼▼▼▼▼▼▼▼▼▼
(0002) 
(0003) // atmega128 칩의 사용 설명서 같은 파일입니다.
(0004) // DDRD, PORTD 같은 칩의 특정 기능들을 컴퓨터가 알아들을 수 있도록 도와줍니다.
(0005) #include <iom128v.h>
(0006) 
(0007) // ▼▼▼▼▼▼▼▼▼▼ 프로그램 전체에서 사용할 함수 미리 알려주기 ▼▼▼▼▼▼▼▼▼▼
(0008) 
(0009) // delay_m 이라는 이름의 '잠시 멈춤' 기능을 나중에 만들 것이라고 미리 알려주는 부분입니다.
(0010) void delay_m(unsigned int m);
(0011) 
(0012) // ▼▼▼▼▼▼▼▼▼▼ 프로그램 전체에서 사용할 재료(변수) 미리 준비하기 ▼▼▼▼▼▼▼▼▼▼
(0013) 
(0014) // 7세그먼트 LED에 숫자 0부터 9까지 표시하기 위한 'LED 램프 패턴'을 미리 저장해 둔 배열입니다.
(0015) // 각 숫자(0x04, 0x2F 등)는 어떤 램프를 켜고 꺼야 하는지에 대한 약속(정보)입니다.
(0016) //
(0017) char number[10] = {0x04, 0x2F, 0x18, 0x09, 0x23, 0x41, 0x40, 0x07, 0x00, 0x01};
(0018) 
(0019) // 0~9 표시가 끝난 후 보여줄 특수 패턴(아마도 LOW, HIGH 글자)의 램프 정보입니다.
(0020) char LOW_HIGH[2] = {0x74, 0x22};
(0021) 
(0022) // 현재 어떤 숫자를 표시할 차례인지 기억하는 '숫자 순서 기억 변수'입니다. 0부터 시작합니다.
(0023) char Ncount = 0;
(0024) 
(0025) // 특수 패턴(LOW_HIGH)의 순서를 기억하는 변수입니다.
(0026) char cnt = 0;
(0027) 
(0028) // ▼▼▼▼▼▼▼▼▼▼ 프로그램의 진짜 시작점, main 함수 ▼▼▼▼▼▼▼▼▼▼
(0029) 
(0030) int main(void)
(0031) {
(0032)     // [초기 설정] DDRD는 칩의 'D 포트'를 입력으로 쓸지, 출력으로 쓸지 정하는 설정 스위치입니다.
(0033)     // 0xFF (이진수 11111111)로 설정해서, D 포트의 8개 핀을 모두 '출력용'(LED 켜는 용도)으로 사용하겠다고 선언합니다.
(0034)     DDRD = 0xFF;
_main:
  i                    --> R20
  segment_data         --> R20
    00070 EF8F      LDI	R24,0xFF
    00071 BB81      OUT	0x11,R24
    00072 C045      RJMP	0x00B8
(0035) 
(0036)     // [무한 반복] while(1)은 '프로그램이 꺼지기 전까지 아래의 코드를 영원히 반복하라'는 뜻입니다.
(0037)     while(1)
(0038)     {
(0039)         // 'number' 배열에서 현재 순서(Ncount)에 맞는 램프 패턴 정보를 가져와 'segment_data'에 임시 저장합니다.
(0040)         char segment_data = number[Ncount];
    00073 E080      LDI	R24,0
    00074 E091      LDI	R25,1
    00075 91E0 010C LDS	R30,Ncount
    00077 27FF      CLR	R31
    00078 0FE8      ADD	R30,R24
    00079 1FF9      ADC	R31,R25
    0007A 8140      LD	R20,Z
(0041) 
(0042)         // [조건문] 만약 지금 표시할 숫자가 0, 1, 2, 3 중 하나라면?
(0043)         if (Ncount <= 3) {
    0007B E083      LDI	R24,3
    0007C 9020 010C LDS	R2,Ncount
    0007E 1582      CP	R24,R2
    0007F F020      BCS	0x0084
(0044)             // 7세그먼트 외에, 아마도 소수점(DP)을 담당하는 8번째 LED를 '켜기' 위해 특별한 계산을 합니다.
(0045)             // segment_data의 8번째 비트 신호를 강제로 0으로 만듭니다. (이 회로에서는 0이 ON, 1이 OFF 신호)
(0046)             // 0x7F는 이진수로 0111 1111 이므로, & 연산으로 8번째 비트만 0으로 바꿀 수 있습니다.
(0047)             // PORTD는 D 포트로 실제 전기 신호를 내보내는 부품입니다.
(0048)             PORTD = segment_data & 0x7F;
    00080 2F84      MOV	R24,R20
    00081 778F      ANDI	R24,0x7F
    00082 BB82      OUT	0x12,R24
(0049)         } else { // 그 외의 숫자(4, 5, 6, 7, 8, 9)를 표시할 때
    00083 C003      RJMP	0x0087
(0050)             // 8번째 LED를 '끄기' 위해 8번째 비트 신호를 강제로 1로 만듭니다.
(0051)             // 0x80은 이진수로 1000 0000 이므로, | 연산으로 8번째 비트만 1로 바꿀 수 있습니다.
(0052)             PORTD = segment_data | 0x80;
    00084 2F84      MOV	R24,R20
    00085 6880      ORI	R24,0x80
    00086 BB82      OUT	0x12,R24
(0053)         }
(0054) 
(0055)         // 다음 숫자를 표시하기 위해 '숫자 순서 기억 변수'의 값을 1 증가시킵니다.
(0056)         Ncount++;
    00087 9180 010C LDS	R24,Ncount
    00089 5F8F      SUBI	R24,0xFF
    0008A 9380 010C STS	Ncount,R24
(0057) 
(0058)         // 약 1초 동안 잠시 멈춰서 눈으로 숫자를 확인할 시간을 줍니다.
(0059)         delay_m(1000);
    0008C EE08      LDI	R16,0xE8
    0008D E013      LDI	R17,3
    0008E D02B      RCALL	_delay_m
(0060) 
(0061)         // [조건문] 만약 숫자 0~9까지 모두 표시했다면? (Ncount가 10이 되었다면?)
(0062)         if(Ncount == 10)
    0008F 9180 010C LDS	R24,Ncount
    00091 308A      CPI	R24,0xA
    00092 F529      BNE	0x00B8
(0063)         {
(0064)             int i;
(0065)             // 특수 패턴을 2번 보여주기 위해 for 반복문을 사용합니다.
(0066)             for(i = 0; i < 2; i++)
    00093 2744      CLR	R20
    00094 2755      CLR	R21
(0067)             {
(0068)                 // 특수 패턴을 표시할 때도 8번째 LED는 꺼져 있어야 하므로, 8번째 비트를 1로 만듭니다.
(0069)                 // cnt++: LOW_HIGH[0]을 쓴 후, 다음을 위해 cnt 값을 1로 만듭니다.
(0070)                 PORTD = LOW_HIGH[cnt++] | 0x80;
    00095 9020 010D LDS	R2,cnt
    00097 2433      CLR	R3
    00098 2D82      MOV	R24,R2
    00099 5F8F      SUBI	R24,0xFF
    0009A 9380 010D STS	cnt,R24
    0009C E08A      LDI	R24,0xA
    0009D E091      LDI	R25,1
    0009E 2DE2      MOV	R30,R2
    0009F 27FF      CLR	R31
    000A0 0FE8      ADD	R30,R24
    000A1 1FF9      ADC	R31,R25
    000A2 8180      LD	R24,Z
    000A3 6880      ORI	R24,0x80
    000A4 BB82      OUT	0x12,R24
(0071) 
(0072)                 // 1초간 멈춤
(0073)                 delay_m(1000);
    000A5 EE08      LDI	R16,0xE8
    000A6 E013      LDI	R17,3
    000A7 D012      RCALL	_delay_m
(0074) 
(0075)                 // 만약 특수 패턴을 2개 모두 보여줬다면(cnt가 2가 되면)
(0076)                 if(cnt == 2)
    000A8 9180 010D LDS	R24,cnt
    000AA 3082      CPI	R24,2
    000AB F419      BNE	0x00AF
(0077)                     // 다음을 위해 다시 0으로 리셋합니다.
(0078)                     cnt = 0;
    000AC 2422      CLR	R2
    000AD 9220 010D STS	cnt,R2
(0079)             }
    000AF 5F4F      SUBI	R20,0xFF
    000B0 4F5F      SBCI	R21,0xFF
    000B1 3042      CPI	R20,2
    000B2 E0E0      LDI	R30,0
    000B3 075E      CPC	R21,R30
    000B4 F304      BLT	0x0095
(0080)             // 모든 과정이 끝났으므로, '숫자 순서 기억 변수'를 다시 0으로 만들어 처음부터 반복하도록 합니다.
(0081)             Ncount = 0;
    000B5 2422      CLR	R2
    000B6 9220 010C STS	Ncount,R2
(0082)         }
(0083)     }
    000B8 CFBA      RJMP	0x0073
    000B9 9508      RET
_delay_m:
  i                    --> R20
  j                    --> R22
  m                    --> R16
    000BA 940E 00CF CALL	push_xgsetF000
(0084)     return 0; // (실제로는 무한루프 때문에 여기까지 오지 않습니다.)
(0085) }
(0086) 
(0087) // ▼▼▼▼▼▼▼▼▼▼ '잠시 멈춤' 기능을 실제로 구현하는 부분 ▼▼▼▼▼▼▼▼▼▼
(0088) 
(0089) // m 밀리초(ms)만큼 프로그램의 진행을 지연시키는 함수입니다.
(0090) // (1000을 넣으면 약 1초)
(0091) void delay_m(unsigned int m){
(0092)     unsigned int i, j;
(0093)     // 컴퓨터에게 쓸데없는 연산을 반복시켜서 시간을 끄는 원리입니다.
(0094)     // 바깥쪽 for문이 m번 반복하면서, 우리가 원하는 시간만큼 지연시킵니다.
(0095)     for(i=0; i<m; i++){
    000BC 2744      CLR	R20
    000BD 2755      CLR	R21
    000BE C00B      RJMP	0x00CA
(0096)         // 안쪽 for문은 정해진 횟수(2100번)만큼 CPU가 아무 의미 없는 일을 하도록 만듭니다.
(0097)         // 이 과정 자체가 시간이 걸리므로 프로그램이 잠시 멈춘 것처럼 보입니다.
(0098)         for(j=0; j<2100; j++){
    000BF 2766      CLR	R22
    000C0 2777      CLR	R23
    000C1 C002      RJMP	0x00C4
(0099)             ; // 세미콜론(;)만 있으면 '아무것도 하지 말고 넘어가라'는 뜻입니다.
(0100)         }
    000C2 5F6F      SUBI	R22,0xFF
    000C3 4F7F      SBCI	R23,0xFF
    000C4 3364      CPI	R22,0x34
    000C5 E0E8      LDI	R30,0x8
    000C6 077E      CPC	R23,R30
    000C7 F3D0      BCS	0x00C2
(0101)     }
    000C8 5F4F      SUBI	R20,0xFF
    000C9 4F5F      SBCI	R21,0xFF
    000CA 1740      CP	R20,R16
(0102) }
    000CB 0751      CPC	R21,R17
    000CC F390      BCS	0x00BF
    000CD 940C 00D4 JMP	pop_xgsetF000
push_xgsetF000:
    000CF 937A      ST	-Y,R23
    000D0 936A      ST	-Y,R22
    000D1 935A      ST	-Y,R21
    000D2 934A      ST	-Y,R20
    000D3 9508      RET
pop_xgsetF000:
    000D4 9149      LD	R20,Y+
    000D5 9159      LD	R21,Y+
    000D6 9169      LD	R22,Y+
    000D7 9179      LD	R23,Y+
    000D8 9508      RET
