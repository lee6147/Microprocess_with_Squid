// ▼▼▼▼▼▼▼▼▼▼ 필요한 부품 및 설명서 불러오기 ▼▼▼▼▼▼▼▼▼▼

// atmega128 칩의 사용 설명서 같은 파일입니다.
// DDRD, PORTD 같은 칩의 특정 기능들을 컴퓨터가 알아들을 수 있도록 도와줍니다.
#include <iom128v.h>

// ▼▼▼▼▼▼▼▼▼▼ 프로그램 전체에서 사용할 함수 미리 알려주기 ▼▼▼▼▼▼▼▼▼▼

// delay_m 이라는 이름의 '잠시 멈춤' 기능을 나중에 만들 것이라고 미리 알려주는 부분입니다.
void delay_m(unsigned int m);

// ▼▼▼▼▼▼▼▼▼▼ 프로그램 전체에서 사용할 재료(변수) 미리 준비하기 ▼▼▼▼▼▼▼▼▼▼

// 7세그먼트 LED에 숫자 0부터 9까지 표시하기 위한 'LED 램프 패턴'을 미리 저장해 둔 배열입니다.
// 각 숫자(0x04, 0x2F 등)는 어떤 램프를 켜고 꺼야 하는지에 대한 약속(정보)입니다.
//
char number[10] = {0x04, 0x2F, 0x18, 0x09, 0x23, 0x41, 0x40, 0x07, 0x00, 0x01};

// 0~9 표시가 끝난 후 보여줄 특수 패턴(아마도 LOW, HIGH 글자)의 램프 정보입니다.
char LOW_HIGH[2] = {0x74, 0x22};

// 현재 어떤 숫자를 표시할 차례인지 기억하는 '숫자 순서 기억 변수'입니다. 0부터 시작합니다.
char Ncount = 0;

// 특수 패턴(LOW_HIGH)의 순서를 기억하는 변수입니다.
char cnt = 0;

// ▼▼▼▼▼▼▼▼▼▼ 프로그램의 진짜 시작점, main 함수 ▼▼▼▼▼▼▼▼▼▼

int main(void)
{
    // [초기 설정] DDRD는 칩의 'D 포트'를 입력으로 쓸지, 출력으로 쓸지 정하는 설정 스위치입니다.
    // 0xFF (이진수 11111111)로 설정해서, D 포트의 8개 핀을 모두 '출력용'(LED 켜는 용도)으로 사용하겠다고 선언합니다.
    DDRD = 0xFF;

    // [무한 반복] while(1)은 '프로그램이 꺼지기 전까지 아래의 코드를 영원히 반복하라'는 뜻입니다.
    while(1)
    {
        // 'number' 배열에서 현재 순서(Ncount)에 맞는 램프 패턴 정보를 가져와 'segment_data'에 임시 저장합니다.
        char segment_data = number[Ncount];

        // [조건문] 만약 지금 표시할 숫자가 0, 1, 2, 3 중 하나라면?
        if (Ncount <= 3) {
            // 7세그먼트 외에, 아마도 소수점(DP)을 담당하는 8번째 LED를 '켜기' 위해 특별한 계산을 합니다.
            // segment_data의 8번째 비트 신호를 강제로 0으로 만듭니다. (이 회로에서는 0이 ON, 1이 OFF 신호)
            // 0x7F는 이진수로 0111 1111 이므로, & 연산으로 8번째 비트만 0으로 바꿀 수 있습니다.
            // PORTD는 D 포트로 실제 전기 신호를 내보내는 부품입니다.
            PORTD = segment_data & 0x7F;
        } else { // 그 외의 숫자(4, 5, 6, 7, 8, 9)를 표시할 때
            // 8번째 LED를 '끄기' 위해 8번째 비트 신호를 강제로 1로 만듭니다.
            // 0x80은 이진수로 1000 0000 이므로, | 연산으로 8번째 비트만 1로 바꿀 수 있습니다.
            PORTD = segment_data | 0x80;
        }

        // 다음 숫자를 표시하기 위해 '숫자 순서 기억 변수'의 값을 1 증가시킵니다.
        Ncount++;

        // 약 1초 동안 잠시 멈춰서 눈으로 숫자를 확인할 시간을 줍니다.
        delay_m(1000);

        // [조건문] 만약 숫자 0~9까지 모두 표시했다면? (Ncount가 10이 되었다면?)
        if(Ncount == 10)
        {
            int i;
            // 특수 패턴을 2번 보여주기 위해 for 반복문을 사용합니다.
            for(i = 0; i < 2; i++)
            {
                // 특수 패턴을 표시할 때도 8번째 LED는 꺼져 있어야 하므로, 8번째 비트를 1로 만듭니다.
                // cnt++: LOW_HIGH[0]을 쓴 후, 다음을 위해 cnt 값을 1로 만듭니다.
                PORTD = LOW_HIGH[cnt++] | 0x80;

                // 1초간 멈춤
                delay_m(1000);

                // 만약 특수 패턴을 2개 모두 보여줬다면(cnt가 2가 되면)
                if(cnt == 2)
                    // 다음을 위해 다시 0으로 리셋합니다.
                    cnt = 0;
            }
            // 모든 과정이 끝났으므로, '숫자 순서 기억 변수'를 다시 0으로 만들어 처음부터 반복하도록 합니다.
            Ncount = 0;
        }
    }
    return 0; // (실제로는 무한루프 때문에 여기까지 오지 않습니다.)
}

// ▼▼▼▼▼▼▼▼▼▼ '잠시 멈춤' 기능을 실제로 구현하는 부분 ▼▼▼▼▼▼▼▼▼▼

// m 밀리초(ms)만큼 프로그램의 진행을 지연시키는 함수입니다.
// (1000을 넣으면 약 1초)
void delay_m(unsigned int m){
    unsigned int i, j;
    // 컴퓨터에게 쓸데없는 연산을 반복시켜서 시간을 끄는 원리입니다.
    // 바깥쪽 for문이 m번 반복하면서, 우리가 원하는 시간만큼 지연시킵니다.
    for(i=0; i<m; i++){
        // 안쪽 for문은 정해진 횟수(2100번)만큼 CPU가 아무 의미 없는 일을 하도록 만듭니다.
        // 이 과정 자체가 시간이 걸리므로 프로그램이 잠시 멈춘 것처럼 보입니다.
        for(j=0; j<2100; j++){
            ; // 세미콜론(;)만 있으면 '아무것도 하지 말고 넘어가라'는 뜻입니다.
        }
    }
}
