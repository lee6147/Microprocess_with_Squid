#include <iom128v.h>

// --- 함수 원형 선언 ---
void write_data(char d);
void write_instruction(char i);
void lcd_init(void);
void delay_m(unsigned int m);
unsigned int ADC_Converter(char channel);
void NumbertoFourDigit(int a);
void F_oc(int a);
// (기타 함수 원형...)
void DectoFloat(int a);
void NumbertoTwoDigit(int a);
void write_string(char *pt);
void NumbertoBinary(char a);
void NumbertoHex(char a);
void Hex_convert(char a);


// --- 전역 변수 ---
unsigned int ADC_result;
char dummy_1000, dummy_100, dummy_10, dummy_1;
unsigned int sec, min, count;
unsigned int volt_digital;

int main(void)
{
    // --- 1. 포트 설정 ---
    // "정상 동작" 코드에서 가져온 LCD 포트 설정
    DDRG = 0x07; // PORTG.0(R/W), G.1(E), G.2(RS) 출력
    DDRC = 0xff; // PORTC (D0~D7) 출력
    
    // 타이머/ADC 기능을 위한 포트 설정 추가
    DDRB = 0x10; // PORTB.4 (OC0) 핀 출력

    // --- 2. 초기화 ---
    lcd_init(); // "정상 동작" 코드의 LCD 초기화 함수

    // ADC 설정 (PF2 = ADC 2번 채널)
    ADMUX = ( (1 << REFS1) | (1 << REFS0) | (0 << ADLAR) | (2 << MUX0) ); 
    ADCSRA = ((1 << ADEN) | (0 << ADSC) | (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0)); //0x87

    // 타이머/카운터 0 설정 (CTC 모드, OC0 핀 토글, 분주비 1)
    TCCR0 = ((1 << WGM01) | (0 << WGM00) |(0 << COM01) | (1 << COM00) | (0 << CS02) | (0 << CS01) | (1 << CS00));

    // --- 3. 인터럽트 비활성화 (핵심 수정) ---
    // LCD 멈춤 현상을 방지하기 위해 모든 인터럽트를 비활성화
    TIMSK = 0x00; 
    // SREG |= 0x80; // << 삭제됨: 불필요한 전역 인터럽트 활성화 제거

    // --- 4. 메인 루프 ---
    while(1)
    {
        // 1. ADC 2번 채널(PF2)에서 값 읽기
        ADC_result = ADC_Converter(2);

        // 2. ADC 값을 8비트(0~255)로 스케일링하여 OCR0 레지스터에 저장
        OCR0 = ADC_result >> 2;

        // 3. 첫 번째 줄에 ADC 값과 OCR0 값 표시
        write_instruction(0x80); // 첫 번째 줄, 첫 번째 칸
        NumbertoFourDigit(ADC_result);
        write_instruction(0x86); // 첫 번째 줄, 7번째 칸
        NumbertoFourDigit(OCR0);

        // 4. 두 번째 줄에 계산된 주파수 표시
        write_instruction(0xc0); // 두 번째 줄, 첫 번째 칸
        F_oc(OCR0); 
    }
}

// =================================================================
// "정상 동작" 코드에서 가져온 LCD 핵심 함수 (수정 없음)
// =================================================================

void write_data(char d){
    PORTG = 0x06; // RS=1(G2), E=1(G1), R/W=0(G0)
    delay_m(1);
    PORTC = d;
    delay_m(1);
    PORTG = 0x04; // E=0 으로 펄스 완료
}

void write_instruction(char i){
    PORTG = 0x02; // RS=0(G2), E=1(G1), R/W=0(G0)
    delay_m(1);
    PORTC = i;
    delay_m(1);
    PORTG = 0x00; // E=0 으로 펄스 완료
}

void lcd_init(void){
    write_instruction(0x30);
    delay_m(15);
    write_instruction(0x30);
    delay_m(1);
    write_instruction(0x30);
    delay_m(1);
    write_instruction(0x30);
    delay_m(1);
    write_instruction(0x38); // 8비트, 2라인, 5x7
    delay_m(1);
    write_instruction(0x0e); // Display ON, Cursor ON
    delay_m(1);
    write_instruction(0x01); // Clear
    delay_m(1);
    // 참고: 0x06 (엔트리 모드)가 없지만, 정상 동작 코드에 없었으므로 그대로 둡니다.
}


void delay_m(unsigned int m){
    unsigned int i, j;
    for(i=0;i<m;i++){
        for(j=0;j<2100;j++){
            ;
        }
    }
}

// =================================================================
// 나머지 유틸리티 함수 (수정 없음)
// =================================================================

// 타이머 0 비교 일치 (CTC) 인터럽트 서비스 루틴
#pragma interrupt_handler timer0_comp_isr:iv_TIM0_COMP
void timer0_comp_isr(void)
{
    // TIMSK = 0x00 이므로 이 함수는 현재 호출되지 않습니다.
}

// 2번 블록의 함수 (주파수 표시)
void F_oc(int a)
{
    float F_oc;
    int iInt, ifrac, ten, one;
    F_oc = 8000.0f / (float)(1+a); // kHz 단위로 바로 계산

    if (F_oc >= 1000.0f) { // 1000kHz (1MHz) 이상인 경우
        F_oc = F_oc / 1000.0f; // MHz로 변환
        iInt = (int)F_oc;
        ifrac = (int)((F_oc - iInt) * 100.0f + 0.5f); // 소수점 둘째 자리

        write_data(iInt + 0x30); // 정수부
        write_data('.');

        ten = ifrac / 10;
        one = ifrac - (ten * 10);

        write_data(ten + 0x30); // 소수점 첫째
        write_data(one + 0x30); // 소수점 둘째
        write_string("MHz  ");

    }
    else { // 1000kHz (1MHz) 미만인 경우
        iInt = (int)F_oc;
        ifrac = (int)((F_oc - iInt) * 100.0f + 0.5f); // 소수점 둘째 자리

        if (ifrac >= 100) {
            ifrac = 99;
        }
        
        // kHz 값 표시 (최대 3자리 정수 + 소수점 2자리)
        if (iInt >= 100) { // 100~999 kHz
             write_data((iInt / 100) + 0x30);
             write_data(((iInt % 100) / 10) + 0x30);
             write_data((iInt % 10) + 0x30);
        } else if (iInt >= 10) { // 10~99 kHz
             write_data(' ');
             write_data((iInt / 10) + 0x30);
             write_data((iInt % 10) + 0x30);
        } else { // 0~9 kHz
             write_data(' ');
             write_data(' ');
             write_data(iInt + 0x30);
        }
        
        write_data('.');

        ten = ifrac / 10;
        one = ifrac - (ten * 10);

        write_data(ten + 0x30);
        write_data(one + 0x30);
        write_string("kHz");
    }
}

unsigned int ADC_Converter(char channel)
{
    ADMUX = ((ADMUX & 0xe0) | channel); // 채널 선택
    ADCSRA |= 1 << ADSC; // 변환 시작
    while(ADCSRA & 0x40); // 변환 완료 대기
    return ADC; // ADC 값 반환 (ADCL + ADCH)
}

void DectoFloat(int a)
{
    float Float;
    int iInt, ifrac, ten, one;
    float Dec = (float)a;
    Float = (5.0f / 1023.0f) * Dec;

    iInt = (int)Float;
    ifrac = (int)((Float-iInt)*100.0f);

    ten = ifrac / 10;
    one = ifrac - (ten * 10);

    write_data(iInt + 0x30);
    write_data('.');
    write_data(ten + 0x30);
    write_data(one + 0x30);
    write_data('V');
}

void NumbertoTwoDigit(int a)
{
    char dummy_10;
    char dummy_1;

    dummy_10 = a / 100;
    a = (a - dummy_10 * 100);

    dummy_10 = a / 10;
    dummy_1 = (a - dummy_10 * 10) / 1 ;

    if(dummy_10 == 0)
    {
        write_data(' ');
    }
    else
    {
        write_data(dummy_10 + 0x30);
    }
    write_data(dummy_1 + 0x30);
}

void NumbertoFourDigit(int a)
{
    dummy_1000 = a / 1000;
    dummy_100 = (a - dummy_1000 * 1000) / 100;
    dummy_10 = (a - dummy_1000 * 1000 - dummy_100 * 100) / 10;
    dummy_1 = (a - dummy_1000 * 1000 - dummy_100 * 100 - dummy_10 * 10) / 1;

    if(dummy_1000 == 0)
    {
        write_data(' ');
    }
    else
    {
        write_data(dummy_1000 + 0x30);
    }

    if((dummy_100 == 0) && (a < 100))
    {
        write_data(' ');
    }
    else
    {
        write_data(dummy_100 + 0x30);
    }

    if((dummy_10 == 0) && (a < 10))
    {
        write_data(' ');
    }
    else
    {
        write_data(dummy_10 + 0x30);
    }

    write_data(dummy_1 + 0x30);
}

void write_string(char *pt)
{
    while((*pt >= ' ') && (*pt <= '~'))
    {
        write_data(*pt);
        pt++;
    }
}

void NumbertoBinary(char a)
{
    char Binary[8];
    char temp;
    int i;
    for (i = 7; i >= 0; i--)
    {
        temp = a - ((a/2) * 2);
        Binary[i] = temp + '0';
        a = a / 2;
    }
    for (i = 0; i < 8; i++)
    {
        write_data(Binary[i]);
        if (i == 3)
        {
            write_data(' ');
        }
    }
}

void NumbertoHex(char a)
{
    char hex_value[4] = {'0','x','0','0'};

    hex_value[2] = a / 16;
    hex_value[3] = a - hex_value[2]*16;

    write_data(hex_value[0]);
    write_data(hex_value[1]);
    Hex_convert(hex_value[2]);
    Hex_convert(hex_value[3]);
}

void Hex_convert(char a)
{
    char hex_convert;
    if (a < 10)
    {
        hex_convert = a + '0';
    }
    else
    {
        hex_convert = a - 10 + 'A';
    }
    write_data(hex_convert);
}
